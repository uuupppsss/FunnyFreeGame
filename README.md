# FunnyFreeGame
Сделаем текстовый рогалик на одного человека, принцип действия игры:
1) создается персонаж, выбираются начальные характеристики, стартует игра
2) персонаж попадает в комнату, где есть враг (или враги), дальше следует бой, где персонаж и враги ходят по очереди, наносят друг другу урон
3) если персонаж выжил, то он молодец
4) переходим в следующую команду и так пока персонаж не помрет
Подобную игру можно делать очень разнообразными способами и потратить на это от пары часов до пары недель. Постараемся сильно не усложнять, но если вы чувствуете в себе силу - можно отклоняться от варианта ниже и писать по-своему.

Опишем сущности - у нас есть игрок и есть враги, вероятно это одинаковые объекты, просто одним управляет игрок, остальными компьютер.
Предположим, что есть абстрактный класс CreatureClass, у которого есть свойство Name (имя игрока или имя врага), свойства Damage (базовый урон), Armor (базовая защита), CurrentHP (текущие хит пойнты) и MaxHP (максимум хит пойнтов). У нас пошаговый бой, в котором будет задействовано больше, чем 2 оппонента, надо будет определять последовательность ходов - добавим свойство Speed, целочисленное, для простоты.
Во время боя персонаж живет до тех пор, пока CurrentHP > 0. Персонаж должен иметь возможность выполнить какое-то действие в свой ход. Эти действия могут быть разными и они могут влиять на состояние врагов или самого персонажа. Игроку нужно будет предоставлять список этих действий, а враги должны иметь возможность выбрать действие случайным образом. Поэтому действия вынесем в отдельные классы и будем хранить в виде объектов в списке возможных действий у каждого персонажа. Заодно получится, что можно создать разные классы с разным набором действий, что довольно круто.
Бой у нас будет в некоторых комнатах, для действий нам потребуется иметь возможность получить список врагов в комнате, возможно что-то еще. 
Так что лучше сразу создать класс Room, дополним его по ходу дела

Создайте абстрактный класс Creature, создайте в нем свойство Stats типа CreatureClass, публичный метод TakeDamage c целочисленным аргументом damage, логическое свойство IsDead и приватный метод Death без аргументов.
в методе TakeDamage обращаемся в свойству CurrentHP и уменьшаем его на показатель damage. Если CurrentHP становится меньше или равен нулю, то запускаем метод Death. Вообще будет удобно создать в классе CreatureClass метод TakeDamage с аргументом damage и уменьшать CurrentHP в нем, кстати у нас есть Armor, который должен уменьшать урон, пропишите его тут же. Это позволит инкапсулировать изменение состояния в классе CreatureClass.
в методе Death пишем сообщение в чат, а свойство IsDead переключаем в true. 

Создайте в классе Room свойство Player с типом Creature и свойство-список Enemies, тип List<Creature>. Добавьте в клаcс Room конструктор, который будет требовать один аргумент типа Player, в конструкторе назначать значение аргумента в свойство Player. Добавьте в клаcс Room публичный метод RunBattle. Действие напишем потом.

Создаем абстрактный класс CreatureAction, в нем определим публичное свойство Title и публичный абстрактный метод Run c двумя аргументами: типа Creature и типа Room, метод не возвращает значение. Будем передавать в действие текущего персонажа или его врага и текущую комнату, чтобы была возможность получить список врагов.
В классе CreatureClass создадим свойство-список объектов CreatureAction с названием Actions. Создайте метод PrintActions в классе CreatureClass, который выведет список действий в консоль - перебираем коллекцию Actions, выводим для каждого действия значение свойства Title. 

Создадим пару классов для действий:
Абстрактный класс AttackOneTarget, наследуем от CreatureAction
Абстрактный класс AttackAllTarget, наследуем от CreatureAction
Абстрактный класс UseItem, наследуем от CreatureAction

Создайте класс Warrior, унаследуйте его от CreatureClass. В конструкторе укажите ему CurrentHP, MaxHP, Damage, Armor
Создайте класс Mage, унаследуйте его от CreatureClass. В конструкторе укажите ему CurrentHP, MaxHP, Damage, Armor

Создайте класс Player, наследуемый от класса Creature. Определите конструктор в классе Player, через который можно будет указать имя игрока (задать свойство Name), а также выбрать класс (Warrior или Mage) - для выбранного класса создается экземпляр obj, который мы назначаем в свойство Stats нашего класса.

Создадим конкретные действия, причем они будут отличаться для игрока и врага, поскольку игрок будет выбирать цель через консоль:
Класс LightAttackTarget, наследуется от AttackOneTarget, в конструкторе назначаем свойство Title - "Легкая атака", реализуем метод Run: 
если переданное существо имеет класс Player (проверка выглядит: if(creature is Player)), то предлагаем пользователю выбор врага (выводим пронумерованный список врагов из списка Enemies). Если переданное существо не Player, то на объекте комнаты получаем свойство Player это будет цель. Дальше генерируется случайное число от 1 до 5, к этому значению добавляется базовый урон атакующего и передается в метод TakeDamage на свойстве Stats цели. Все действия должны сопроводждаться выводом текста в консоль, чтоб было понятно, что происходит.

Класс MultiAttackTarget, наследуется от AttackAllTarget, в конструкторе назначаем свойство Title - "Атака по группе", реализуем метод Run:
создает коллекцию targets типа Creature, далее аналогично, если переданное существо имеет класс Player, то цели это список Enemies на объекте комнаты - добавляем их в targets, в противном случае - цель игрок, добавляем в targets его из свойства Player объекта комнаты. Далее для каждой цели генерируется урон 1-3, к этому значению добавляется половина базового урона атакующего и передается цели в метод TakeDamage на свойстве Stats. 

В конструкторе класса Warrior добавьте экземпляры классов LightAttackTarget и MultiAttackTarget в свойство Actions;

В классе Creature создайте публичный абстрактный метод RunAction, принимает один аргумент типа Room

В классе Player реализуйте метод RunAction:
1) выводим список возможных действий (PrintActions на свойстве Stats)
2) игрок указывает номер действия, считаем, что это индекс, обращаемся к Stats.Actions[индекс] и вызываем на этом действии метод Run, передаем туда ключевое слово this (текущий объект) и комнату из аргумента - получится запуск атаки

Создайте класс Enemy, наследуемый от класса Creature, создайте в нем конструктор, который случайным образом назначает класс (Warrior или Mage) в свойство Stats. Не забудь дать врагу имя!
В классе Enemy реализуйте метод RunAction - проверяем свойство IsDead, если оно равно true, то прерываем действие метода, выбираем случайное действие из коллекции Stats.Actions, вызываем на нем метод Run, передаем туда this и комнату из аргумента.

В класс Creature добавьте публичный метод RandomSpeed, который будет назначать в свойство Speed случайное число от 1 до 10.

В классе Room в конструкторе допишите создание 1-3 врагов и добавление их в коллекцию Enemies.
В классе Room реализуйте метод RunBattle: 
0) создадим цикл - до тех пор пока жив игрок или пока живы все враги, пункты 1, 2, 3 внутри цикла. Создайте переменную round, в цикле в начале выводите строку раунд такой-то, раунд увеличивается на 1
1) определим порядок ходов - игроку и всем врагам нужно вызвать метод RandomSpeed
2) создайте коллекцию типа Creature, добавьте туда игрока и всех врагов, отсортируйте по убыванию свойства Speed
3) на каждом объекте типа Creature вызывайте метод RunAction, передаем туда this (ссылку на комнату)
4) Если цикл завершился, а игрок еще жив, то он победил. Можно его поздравить с зачисткой комнаты.

Для класса Mage нужно определить другие действия, в целом все аналогично классу Warrior

В классе Program в методе Main создайте объект Player, далее создайте цикл, в котором будет создаваться объект Room, передайте в него Player, вызовите RunBattle. Цикл длится пока игрок жив. После цикла - конец игры.

Заметки: 
в методах RunAction классов Player и Enemy полезно добавить вывод информации - показывайте состояние hp игрока перед его ходом
Показывайте выбранное действие игрока или какое действие выбрал враг.

Можно создать разных врагов с помощью новых классов, унаследованных от класса Enemy (а класс Enemy можно сделать абстрактным). У новых классов-врагов в конструкторе меняем имя, делаем прибавку к статам, добавляем или убираем действия класса (Actions).

В начале метода RunAction классов Player и Enemy можно поменять цвет текста в консоли через Console.ForegroundColor. Получится, что действия игрока будут одним цветом, а действия разных врагов - другим. Цвет можно сохранить в классе Creature, задавать в конструкторе объекта Player или Enemy (или наследников Enemy) также как имя.

В конструкторе класса Room можно добавить текст, что герой (имя) попал в комнату, его окружают враги (их имена).
В методе RunBattle класса Room при переборе очереди из существ, на которых вызывается метод RunAction, проверять перед каждым ходом, жив ли игрок. Если игрок погиб, то цикл следует прервать. Рядом с этой же проверкой можно поставить задержку в одну секунду, чтобы бой шел несколько секунд, а не мгновенно.

Комнате можно добавить случайное состояние, которое будет влиять на разные типы атак. Можно сделать перечисление RoomStatus и создать свойство с этим типом в классе Room. Назначать случайным образом в конструкторе комнаты. Пример использования: 
У комнаты статус "Туман", выбор существом действия, унаследованного от AttackOneTarget имеет шанс промаха. Шанс промаха прописывается в классе LightAttackTarget вместе с проверкой на статус тумана в комнате.

Можно добавить использование вещей, магии, разнообразные классы, донат, действия, донат, награды за зачистку комнаты, донат, опыт с получением уровней, донат, сохранения/загрузку а еще донат и тд и тп.
